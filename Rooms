/* @pjs pauseOnBlur="true"; globalKeyEvents="true";*/
//circle puzzle
color bkg = color(255);
float circRad;
ArrayList<Circle> circles;
int numCircles = 5;
int numBreaks = 5; 
float startRadArc;
float[] arcPositions;
Circle active;
int activeIndex;
float radsAnimated = PI/16;
boolean animating,shuffling;
boolean dir; //left = true, right = false
int maxCol = 200;
int newTime, oldTime;
float fps = 8;
float fps2 = 15;
boolean win;
int count = 0;
int fadeFps = 30;
color breakc[]; //color for breaks
float rad;
PImage back; 


void setup(){
 //size(screenWidth,screenHeight);  // Processing 1.5
 
 back = loadImage("Game2.png");
 size(800,600); // Processing 2.0+
 //size(500,500);
 background(back);
 smooth();
 noStroke();
 puzzleOne();



}

void draw(){
  background(back);
  runAnim();

  for(int x=circles.size()-1; x>=0; x--){
   Circle c = circles.get(x);
   c.render(); 
  }
  
  /*
  if(win){
    float num = (fadeFps - count)/fadeFps*(255/fadeFps);
    //background(bkg,2);
  }
  */
  
}

void keyPressed(){
  if(!win && !animating){
     if(keyCode == UP){
      puzzleUp();
     
    }else if(keyCode == DOWN){
      puzzleDown();
    }else if(keyCode == LEFT){
      puzzleLeft();
      
    }else if(keyCode == RIGHT){
      puzzleRight();
      
    }else if(key == 'r'){
     reset();
    }
  }
}

boolean checkForWin(){
  Circle first = circles.get(0);
  for(int x=1; x<circles.size(); x++){
    Circle c = circles.get(x);
   
    for(int b=0; b<numCircles; b++){
      float th1 = (first.breaks.get(b).theta1+100*PI) % (2*PI+.0001);
      float th2 = (c.breaks.get(b).theta1+100*PI) % (2*PI+.0001);
     
      if(abs(th1 - th2) > .1){
        return false;
      }
    }
  }
  return true;
}

class Circle{
  int level;
  color c;
  ArrayList<CBreak> breaks;
  float randRads;
  boolean initDir;
  int count;
  int radV;
 
  Circle(int level, float r,float g,float b, int numBreaks, int radV){
    breaks = new ArrayList<CBreak>();
   this.level = level;
   this.radV = radV;
   count = 0;
   this.c = color(r,g,b);
   for(int x=0; x<numBreaks; x++){
    float th = startRadArc;
    breaks.add(new CBreak(arcPositions[x],arcPositions[x]+startRadArc,breakc[x]));
   }
  }
  
  void animate(float rads){
   if(!dir){ //left
    for(CBreak b : breaks){
     b.theta1 += rads;
     b.theta2 += rads; 
    }
    
   }else{ //right
       for(CBreak b : breaks){
     b.theta1 -= rads;
     b.theta2 -= rads; 
    
   } 
    
  }
  }
  
  void shuffle(){
    randRads = radsAnimated*((int)random(15));
    //Random r = new Random();
    if((int)(Math.random()*2) == 0){  
      initDir = true;
    }else{
     initDir = false; 
    }
   /* for(CBreak b : breaks){
     b.theta1 += randRads;
     b.theta2 += randRads; 
    
   } 
   */
   
  }
  
  void render(){
   if(this == active){
     stroke(255);
     strokeWeight(4);
     fill(c); 
   }else{ 
     noStroke();
     fill(bkg);
     ellipse(width/2,height/2,circRad*level,circRad*level);
     fill(c,100);
   
   }
   ellipse(width/2,height/2,circRad*level,circRad*level);
   for(CBreak b : breaks){
    b.render(this); 
   }
  }
  
}// CIRCLE CLASS

class CBreak{
 float theta1,theta2;
 color colour;
 float rad;

 CBreak(float theta1, float theta2,color colour){
  this.theta1 = theta1;
  this.theta2 = theta2; 
  this.colour = colour;
 
  //this.colour = color(random(255),random(255),random(255));
 }
 
 void render(Circle c){
  float rad = circRad*c.radV;
  //fill(this.colour);
  fill(this.colour);
  arc(width/2, height/2, rad+2, rad+2, theta1, theta2);
  
 }
}// Circle breaks 
 
 
  // We must implement run, this gets triggered by start()
  void runAnim () {
    //newTime = millis() - oldTime;
    if(shuffling){
      for(Circle c: circles){
        dir = c.initDir;
      c.animate(c.randRads/fps2);
      }
      count++;
      if(count >= fps2){
        shuffling = false;
        count = 0;
        
      }    
      
    }else if(animating){
      active.animate(radsAnimated/fps);
      count++;
      if(count == fps){
      animating = false;
      count = 0;
      }
      if(!animating){
         if(checkForWin()){
           win = true;
           count=0;
          //System.out.println(win); 
          }
      }

    
    }else if(win){
         
         if(count == fadeFps){
         numCircles++;
         if(numCircles > 30){
          numCircles = 0; 
         }
         setup(); 
         }else{
           count++;
         }
    }   
      
    }
    
    //oldTime = millis();
    
void puzzleUp(){
  if(activeIndex == circles.size()-1){
         activeIndex = 0;
       }else{
         activeIndex++;
       }
      
  active = circles.get(activeIndex);
}//moveUp function


void puzzleDown(){
   if(activeIndex == 0){
       activeIndex = circles.size()-1;
       }else{
         activeIndex--;
       }
      
       active = circles.get(activeIndex); 
}//moveDown function

void puzzleLeft(){
   animating = true;
   dir = true; 
}//moveLeft function

void puzzleRight(){
    animating = true;
    dir = false;  
}//moveRight function
  
void reset(){
 setup(); 
}//reset function

void puzzleOne(){
 numCircles = 5;
 numBreaks = 5;  
 win = false;
 count = 0;
 circles = new ArrayList<Circle>();
 circRad = (height-40)/7;
 breakc = new color[numBreaks];
 arcPositions = new float[numBreaks];
 startRadArc = TWO_PI/numBreaks;
 for(int x=0; x<numBreaks; x++){
   if(x==0)
     arcPositions[x] = arcPositions[x]+TWO_PI/numBreaks;
   else
     arcPositions[x] = arcPositions[x-1]+TWO_PI/numBreaks;
     
     breakc[x] = color(random(255),random(255),random(255));
 }
 for(int x=0; x<numCircles; x++){
  Circle c = new Circle(x+1,random(maxCol),random(maxCol),random(maxCol),numBreaks,x+1);
  c.shuffle();
  circles.add(c);
 }
 

 
 
 active = circles.get(0);
 activeIndex = 0;
 animating = false;
 
 newTime = oldTime = 0;
 shuffling = true;
}

  





